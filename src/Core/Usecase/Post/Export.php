<?php

/**
 * Ushahidi Platform Post Export Use Case
 *
 * @author     Ushahidi Team <team@ushahidi.com>
 * @package    Ushahidi\Platform
 * @copyright  2014 Ushahidi
 * @license    https://www.gnu.org/licenses/agpl-3.0.html GNU Affero General Public License Version 3 (AGPL3)
 */

namespace Ushahidi\Core\Usecase\Post;

use Ushahidi\App\Repository\ExportJobRepository;
use Ushahidi\Core\Tool\AuthorizerTrait;
use Ushahidi\Core\Tool\FormatterTrait;
use Ushahidi\Core\Usecase\SearchRepository;
use Ushahidi\Core\Usecase\SearchUsecase;
use Traversable;
class Export extends SearchUsecase
{
	use AuthorizerTrait;
	private $payload;
	private $session;
	private $data;
	private $postExportRepository;
	private $exportJobRepository;
	private $formAttributeRepository;


	// provides setFormatter to assign the formatter the usecase will use
	use FormatterTrait;

	// - VerifyParentLoaded for checking that the parent exists
	use VerifyParentLoaded;

	public function setRepository(SearchRepository $repo)
	{
		return parent::setRepository($repo); // TODO: Change the autogenerated stub
	}

	//FIXME inject somewhere else
	private function setup() {
		$this->exportJobRepository = service('repository.export_job');
		$this->formAttributeRepository = service('repository.form_attribute');
		$this->data = service('factory.data');
		$this->postExportRepository = service('repository.posts_export');
		$this->session = service('session');
	}
	public function interact()
	{
		$this->setup();
		// Construct a Search Data object to hold the search info
		$data = $this->data->get('search');
		$job_id = $this->payload['job_id'];
		$add_header = $this->payload['add_header'];

		// Set the baseline filter parameters
		$filters = [
			'limit' => $this->payload['limit'],
			'offset' => $this->payload['offset'],
		];
die;
		if ($job_id) {
			// Load the export job
			$job = $this->exportJobRepository->get($job_id);

			$this->session->setUser($job->user_id);
			// Merge the export job filters with the base filters
			if ($job->filters) {
				$filters = array_merge($filters, $job->filters);
			}

			// Set the fields that should be included if set
			if ($job->fields) {
				$data->include_attributes = $job->fields;
			}
		}

		foreach ($filters as $key => $filter) {
			$data->$key = $filter;
		}

		$this->postExportRepository->setSearchParams($data);
		$posts = $this->postExportRepository->getSearchResults();
		$this->formatter->setAddHeader($add_header);
		//fixme add post_date
		$form_ids = $this->postExportRepository->getFormIdsForHeaders();
		$attributes = $this->formAttributeRepository->getByForms($form_ids, $data->include_attributes);

		$keyAttributes = [];
		foreach ($attributes as $key => $item) {
			$keyAttributes[$item['key']] = $item;
		}

		// // ... remove any entities that cannot be seen
		foreach ($posts as $idx => $post) {
			// Retrieved Attribute Labels for Entity's values
			$post = $this->postExportRepository->retrieveMetaData($post->asArray(), $keyAttributes);
			$posts[$idx] = $post;
		}

		if (empty($job->header_row)) {
			$job->setState(['header_row' => $attributes]);
			$this->exportJobRepository->update($job);
		}
		$header_row = $this->formatter->createHeading($job->header_row, $posts);
		$this->formatter->setHeading($header_row);
		$formatter = $this->formatter;
		/**
		 * KeyAttributes is sent instead of the header row because it contains
		 * the attributes with the corresponding features (type, priority) that
		 * we need for manipulating the data
		 */
		$file = $formatter($posts, $keyAttributes);
		return [
			[
				'file' => $file->file,
			]
		];
	}

	/**
	 * Inject a repository that can create entities.
	 *
	 * @todo  setPayload doesn't match signature for other usecases
	 *
	 * @param  $repo Iterator
	 * @return $this
	 */
	public function setPayload(Traversable $payload)
	{
		$this->payload = $payload;
		return $this;
	}

}
